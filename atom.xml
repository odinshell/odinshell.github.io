<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asjid Kalam</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://odinshell.github.io/"/>
  <updated>2021-03-13T17:16:59.931Z</updated>
  <id>https://odinshell.github.io/</id>
  
  <author>
    <name>Asjid Kalam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prototype Pollution to Command Injection</title>
    <link href="https://odinshell.github.io/2021/03/13/Prototype-Pollution-to-Command-Injection/"/>
    <id>https://odinshell.github.io/2021/03/13/Prototype-Pollution-to-Command-Injection/</id>
    <published>2021-03-13T16:49:04.000Z</published>
    <updated>2021-03-13T17:16:59.931Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SecretMerger</strong> is a medium difficulty <em>web challenge</em> created for DomeCTF 2021, and in this blog we’ll be discussing how to solve the challenge(the intended way).</p><p><img src="/2021/03/13/Prototype-Pollution-to-Command-Injection/chall_files.png" alt="chall-files"></p><p>We’re given a node project with 3 files:</p><p>├── <code>app.js</code> -&gt; Contains the main application logic<br>├── <code>package.json</code> -&gt; Package information and dependencies used<br>└── <code>utils.js</code>   -&gt; ObjectMerger logic</p><p>We can first inspect the <code>app.js</code> to understand what happens server-side.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.end(<span class="string">'Welcome to the Secret Merge service!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/secret'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> path = req.body.path;</span><br><span class="line">    <span class="keyword">var</span> value = req.body.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> path  !== <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        secretMerger(&#123;&#125;, path, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        exec(<span class="string">'cat info.txt '</span> + secretSpell, (err, resp)=&gt; &#123;</span><br><span class="line">            res.end(resp);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        res.end(<span class="string">'Server Occured an error. Make sure you get the payload right!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"secret merger started!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Route to <code>GET /</code> does nothing else other than the welcome message, we’ll have to dig through <code>POST /secret</code> to find out what’s going on. </p><p>It takes two <code>req.body</code> values, <code>path</code> &amp; and <code>value</code>, if they’re defined, they’re passed to the <code>secretMerger()</code> function which is defined in <code>utils.js</code>. So we can take a look at how the <code>secretMerger()</code> processes the values.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">for</span> (len = path.length; i &lt; len; ++i) &#123;</span><br><span class="line">     k = path[i];</span><br><span class="line">     isLastElement = i === len - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (settingAValue &amp;&amp; !obj) &#123;</span><br><span class="line">         obj = &#123;&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (settingAValue &amp;&amp; isLastElement) &#123;</span><br><span class="line">         obj[k] = value;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (settingAValue) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="string">'object'</span> !== <span class="keyword">typeof</span> obj[k]) &#123;</span><br><span class="line">                 obj[k] = &#123;&#125;;</span><br><span class="line">             &#125;</span><br><span class="line">             obj = obj[k];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (obj &amp;&amp; k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                 obj = obj[k];</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure><p>Reading the code, we can see that the function simply merges two objects together(<em>source</em> as an empty object and <em>destination</em> as it’s path and value). Here’s how the merge works:</p><p>For each property in source, check if that property is object itself. If it is then go down recursively and try to map child object properties from source to destination. So essentially we merge object hierarchy from source to destination (same as that of <code>$.extent()</code> in <em>jQuery</em> or <code>_.merge()</code> in <em>lodash</em>).  </p><p>In JavaScript, when new objects are created, they carry over the properties and methods of the prototype “object”, which contains basic functionalities such as <code>toString</code>, <code>constructor</code>, and <code>hasOwnProperty</code>. Object-based inheritance gives JavaScript flexibility and efficiency, but it also makes it vulnerable to tampering. Attackers can make application-wide changes to all objects by modifying object, hence creating a <strong>prototype pollution</strong> vulnerability. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">'cat info.txt '</span> + secretSpell, (err, resp)=&gt; &#123;</span><br><span class="line">    res.end(resp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Going back to <code>app.js</code> again, we can see it then attempts to <code>cat info.txt</code> along with a <code>secretSpell</code> variable, which is not in scope. Also it uses <code>child_process.exec()</code> to spawn subprocess, so we could possibly get an arbitrary OS command injection abusing the <code>secretSpell</code> variable. Here’s how the payload works:</p><ul><li>Create a malicious destination object to pollute <code>path</code>.</li><li>Overwrite the <code>secretSpell</code> variable.</li><li>Getting arbitrary command injection.</li></ul><p>We can access <code>secretSpell</code> through <code>__proto__</code> property of the destination object:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data <span class="string">'&#123;"path":"__proto__.secretSpell", "value":"; ls"&#125;'</span> -H <span class="string">"Content-Type: application/json"</span> --url http://127.0.0.1:3000/secret -X POST</span><br></pre></td></tr></table></figure><p><img src="/2021/03/13/Prototype-Pollution-to-Command-Injection/ls.png" alt="code-executed!"></p><p>After code execution, we can find a directory <code>TopSecretData</code> with the flag in it.</p><p><img src="/2021/03/13/Prototype-Pollution-to-Command-Injection/flag.png" alt="flag.txt"></p><blockquote><p>DomeCTF{ea645983443b225edb3046529bf083be}</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;SecretMerger&lt;/strong&gt; is a medium difficulty &lt;em&gt;web challenge&lt;/em&gt; created for DomeCTF 2021, and in this blog we’ll be discussin
      
    
    </summary>
    
    
    
      <category term="web, ctf" scheme="https://odinshell.github.io/tags/web-ctf/"/>
    
  </entry>
  
  <entry>
    <title>f=g+h - A* Pathfinding</title>
    <link href="https://odinshell.github.io/2020/11/15/f-g-h-A-Pathfinding/"/>
    <id>https://odinshell.github.io/2020/11/15/f-g-h-A-Pathfinding/</id>
    <published>2020-11-15T09:15:41.000Z</published>
    <updated>2020-11-15T10:34:17.164Z</updated>
    
    <content type="html"><![CDATA[<p><strong>f=g+h</strong> is an medium difficulty programming/misc challenge from <a href="https://yetanothersec.com/yascon2020/" target="_blank" rel="noopener">YASCON 2020</a>, in this blog we’ll be discussing the intended way to solve the challenge.</p><h5 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h5><p>We’re given an archive with a word map and a text file with a maze in it. From the text file description and the challenge name, it’s clear that we have to implement A* pathfinding algorithm and find the fastest route to the element <strong>X</strong>.</p><p>Pathfinding is basically plotting the shortest route between two points. It is a more practical variant on solving mazes. This field of research is based heavily on Dijkstra’s algorithm for finding the shortest path on a weighted graph. Here we’re going to use an extension of Dijkstra’s algorithm called A* because it achieves better performance by using heuristics to guide its search.</p><p><img src="https://miro.medium.com/max/252/1*2jRCHqAbTCY7W7oG5ntMOQ.gif" alt="Dijkstra&#39;s Algorithm" title="Dijkstra&#39;s Algorithm"> </p><p style="color:#808080; text-align:center; font-size:small;"><em>Dijkstra's Algorithm</em></p><p><img src="https://miro.medium.com/max/252/1*HppvOLfDxXqQRFn0Cv2dHQ.gif" alt="A* Algorithm" title="A* Algorithm"></p><p style="color:#808080; text-align:center; font-size:small;"><em>A* Algorithm</em></p><h5 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm:"></a>A* Algorithm:</h5><p>A* assigns a weight to each open node equal to the weight of the edge to that node plus the approximate distance between that node and the finish. This approximate distance is found by the heuristic and represents a minimum possible distance between that node and the end. This allows it to eliminate longer paths once an initial path is found.</p><p>One important aspect of A* is <em><code>f = g + h</code></em>. The f, g and h variables are in our Node class and get calculated every time we create a new node. Quickly I’ll go over what these variables mean.</p><blockquote><ul><li>F is the total cost of the node.</li><li>G is the distance between the current node and the start node.</li><li>H is the heuristic — estimated distance from the current node to the end node.</li></ul></blockquote><p>We won’t be implementing A* ourselves, as it’s a waste of time to reinvent the wheel, so instead we’ll be using someone else’s code 😅<br>Here’s a python implementation of A* from scratch: <a href="https://gist.github.com/ryancollingwood/32446307e976a11a1185a5394d6657bc" target="_blank" rel="noopener">gist</a>. All thanks to <a href="https://github.com/ryancollingwood" target="_blank" rel="noopener">ryancollingwood</a> 🙌</p><p><img src="/2020/11/15/f-g-h-A-Pathfinding/Pasted%20image%2020201114210854.png" alt="the maze"></p><p>Change the maze on <em>line 137</em> with the maze given in the challenge file, Set the destination value to coordinates of the element ‘X’, in our case (7, 8). So the script starts finding the shortest path from (0,0) to (7,8).</p><p><img src="/2020/11/15/f-g-h-A-Pathfinding/Pasted%20image%2020201114211632.png" alt="path coordinates"></p><p>After getting the coordinates, we need to use them on the image and map out its respective character. All we have to do is just figure out what character stands in the path coordinates to find the flag. You can do that in many ways or even manually. I have created a script to visualize it using Matplotlib and OpenCV, it basically creates a table from the image and plots the points using the coordinates.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> imutils <span class="keyword">import</span> contours</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load image, grayscale, Gaussian blur, Otsu's threshold</span></span><br><span class="line">image = cv2.imread(<span class="string">'map.png'</span>)</span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">blur = cv2.GaussianBlur(gray, (<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">thresh = cv2.threshold(blur, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find contours and remove text inside cells</span></span><br><span class="line">cnts = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cnts = cnts[<span class="number">0</span>] <span class="keyword">if</span> len(cnts) == <span class="number">2</span> <span class="keyword">else</span> cnts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cnts:</span><br><span class="line">    area = cv2.contourArea(c)</span><br><span class="line">    <span class="keyword">if</span> area &lt; <span class="number">4000</span>:</span><br><span class="line">        cv2.drawContours(thresh, [c], <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Invert image</span></span><br><span class="line">invert = <span class="number">255</span> - thresh</span><br><span class="line">offset, old_cY, first = <span class="number">10</span>, <span class="number">0</span>, <span class="literal">True</span></span><br><span class="line">visualize = cv2.cvtColor(invert, cv2.COLOR_GRAY2BGR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find contours, sort from top-to-bottom and then sum up column/rows</span></span><br><span class="line">cnts = cv2.findContours(invert, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cnts = cnts[<span class="number">0</span>] <span class="keyword">if</span> len(cnts) == <span class="number">2</span> <span class="keyword">else</span> cnts[<span class="number">1</span>]</span><br><span class="line">(cnts, _) = contours.sort_contours(cnts, method=<span class="string">"top-to-bottom"</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cnts:</span><br><span class="line">    <span class="comment"># Find centroid</span></span><br><span class="line">    M = cv2.moments(c)</span><br><span class="line"></span><br><span class="line">    cX = int(M[<span class="string">"m10"</span>] / M[<span class="string">"m00"</span>])</span><br><span class="line">    cY = int(M[<span class="string">"m01"</span>] / M[<span class="string">"m00"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># New row</span></span><br><span class="line">    <span class="keyword">if</span> (abs(cY) - abs(old_cY)) &gt; offset:</span><br><span class="line">        <span class="keyword">if</span> first:</span><br><span class="line">            row, table = [], []</span><br><span class="line">            first = <span class="literal">False</span></span><br><span class="line">        old_cY = cY</span><br><span class="line">        table.append(row)</span><br><span class="line">        row = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(tuples)</span>:</span> </span><br><span class="line">    new_tup = () </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> reversed(tuples): </span><br><span class="line">        new_tup = new_tup + (k,) </span><br><span class="line">    <span class="keyword">return</span> new_tup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># coordinates of the flag string</span></span><br><span class="line">flag = [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), </span><br><span class="line">        (<span class="number">0</span>, <span class="number">6</span>), (<span class="number">0</span>, <span class="number">7</span>), (<span class="number">0</span>, <span class="number">8</span>), (<span class="number">0</span>, <span class="number">9</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">8</span>), </span><br><span class="line">        (<span class="number">4</span>, <span class="number">8</span>), (<span class="number">5</span>, <span class="number">8</span>), (<span class="number">6</span>, <span class="number">8</span>), (<span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">flag2 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    flag2.append(Reverse(i))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># X(base=19, diff=39) : Y(base=20, diff=42)</span></span><br><span class="line"><span class="keyword">for</span> coordinates <span class="keyword">in</span> flag2:</span><br><span class="line">    <span class="keyword">if</span>(int(coordinates[<span class="number">0</span>]) == <span class="number">0</span>):</span><br><span class="line">        cX = <span class="number">19</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cX = <span class="number">19</span> + (coordinates[<span class="number">0</span>] * <span class="number">39</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(int(coordinates[<span class="number">1</span>]) == <span class="number">0</span>):</span><br><span class="line">        cY = <span class="number">20</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cY = <span class="number">20</span> + (coordinates[<span class="number">1</span>] * <span class="number">41</span>)</span><br><span class="line">    </span><br><span class="line">    print(cX, cY)</span><br><span class="line"></span><br><span class="line">    cv2.circle(visualize, (cX, cY), <span class="number">10</span>, (<span class="number">36</span>, <span class="number">255</span>, <span class="number">12</span>), <span class="number">-1</span>) </span><br><span class="line">    cv2.imshow(<span class="string">"pathfinding"</span>, visualize)</span><br><span class="line">    cv2.waitKey(<span class="number">200</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">print(<span class="string">'Rows: &#123;&#125;'</span>.format(len(table)))</span><br><span class="line">print(<span class="string">'Columns: &#123;&#125;'</span>.format(len(table[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure><p><img src="/2020/11/15/f-g-h-A-Pathfinding/pathfinding.gif" alt="visualization"></p><p>And we get the string - <strong>AESKDCDOHKKLAOPOLGTMLOME</strong><br>Since the flag is MD5Sum of the path string,</p><blockquote><p><span style="color:#9e1900;">YASCON{45131ca9f5140debc67047351d21a403}</span></p></blockquote><hr><p>If you wanted to try it for yourself, here’s the challenge files: <a href="http://www.mediafire.com/file/2x0e9xstwyrrjqn/chall.zip/file" target="_blank" rel="noopener">chall.zip</a>  ✌️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;f=g+h&lt;/strong&gt; is an medium difficulty programming/misc challenge from &lt;a href=&quot;https://yetanothersec.com/yascon2020/&quot; target=&quot;_b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Crackme - Golang Reversing</title>
    <link href="https://odinshell.github.io/2020/11/15/crackme-Golang-Reversing/"/>
    <id>https://odinshell.github.io/2020/11/15/crackme-Golang-Reversing/</id>
    <published>2020-11-15T06:40:41.000Z</published>
    <updated>2020-11-15T09:49:05.873Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Crackme</strong> is an easy reverse engineering challenge from <a href="https://yetanothersec.com/yascon2020/" target="_blank" rel="noopener">YASCON 2020</a>, in this blog we’ll be discussing the intended way to solve the challenge.</p><p><img src="/2020/11/15/crackme-Golang-Reversing/Pasted%20image%2020201114143252.png" alt="binary"></p><h6 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h6><p>We’re given a windows PE executable binary, non-stripped and on execution, it just asks “<em>Dead or Alive?</em>“. It’s the typical crackme chall and is pretty much static reverse engineering so we’ll be using <a href="https://ghidra-sre.org/" target="_blank" rel="noopener">Ghidra</a> to solve this challenge. </p><p>After analyzing the binary, we can start looking for the main function. Usually, Go binaries are huge and a lot of functions are embedded in binary by the compiler. C compiled programs would import the library they use and could be seen in the import section. But in Go, the functions used are actually compiled in the binary itself, and only a few libraries were imported, in my case <code>kernel32</code> and <code>winmm</code>. So after a little digging, we could find the main function named <code>main.main</code>.</p><p><img src="/2020/11/15/crackme-Golang-Reversing/Pasted%20image%2020201114141938.png" alt="main fn"></p><p>Looking into the main function we find the <code>Fprint()</code> to the few strings we see when executing the binary,</p><p><img src="/2020/11/15/crackme-Golang-Reversing/Pasted%20image%2020201114143113.png" alt="strings"></p><p>Then it takes <em>STDIN</em> using the <code>fmt.Fscan()</code> function and perform <code>strings.genSplit()</code>. <code>Split</code> function splits a string into all substrings separated by the given separator and returns a slice that contains these substrings. So basically it creates an array of characters from the user-input and remaining comparisons are performed in the array, element by element.</p><p><img src="/2020/11/15/crackme-Golang-Reversing/Pasted%20image%2020201114144708.png" alt="length validation"></p><p>It then continues to find the length of the input string and checks if it is greater than 10 characters. If not it displays the error message and exits the program, and on giving input with greater than 10 characters we get a different error message. So the flag is probably 10 chars or larger. </p><p><img src="/2020/11/15/crackme-Golang-Reversing/Pasted%20image%2020201114151420.png" alt="comparisons"></p><p>It then starts a huge <em>if comparison</em> with the elements of the array and a hardcoded characters, and if any comparison returns <code>false</code> it prints out an error message and exits the program. So the objective here is to trace the characters which are being compared, from the array to the hardcoded elements.</p><p>Reading the disassembly, it looks like the comparisons are happening with an index value added to the base index value, except for the ‘Y’ comparison.</p><p>That is,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">string</span>(array[<span class="number">0</span>+<span class="number">1</span>]) == <span class="string">"C"</span>) &amp;&amp; each other comparisons &#123; </span><br><span class="line">    <span class="comment">// returns true and exits. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It continues to perform the comparisons for the rest of the elements in the array with the added index value ‘1’. And on arranging the characters to which is compared in the right order of user input, we get the flag.</p><blockquote><p><span style="color:#9e1900;">YASCON{W3lc0me_t0_gO_r3v3rs1nG}</span></p></blockquote><p><img src="/2020/11/15/crackme-Golang-Reversing/Pasted%20image%2020201114151700.png" alt="yeeeeyyy!!"></p><hr><p><em>source code: <a href="https://gist.github.com/Asjidkalam/0bf9949d30de767daf6067460b768d1f" target="_blank" rel="noopener">main.go</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Crackme&lt;/strong&gt; is an easy reverse engineering challenge from &lt;a href=&quot;https://yetanothersec.com/yascon2020/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Reverse Engineering Flutter apps: NullBreaker CTF</title>
    <link href="https://odinshell.github.io/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/"/>
    <id>https://odinshell.github.io/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/</id>
    <published>2020-05-25T10:31:00.000Z</published>
    <updated>2020-05-26T20:43:50.455Z</updated>
    
    <content type="html"><![CDATA[<p>We have a conducted a CTF recently - <a href="https://ctf.0xdeadbeef.games" target="_blank" rel="noopener">NullBreaker CTF</a> in association with <a href="https://ehackify.com/" target="_blank" rel="noopener">eHackify</a> and <a href="https://twitter.com/yetanothersec" target="_blank" rel="noopener">YAS</a>, and in this post, I’ll be discussing about reverse engineering one of the android challenge, <strong>TapTap</strong>. </p><p><em>Files:</em><br><a href="https://drive.google.com/file/d/1AiGME7lV9MCmIzmmOrx2FkO_Kbb8aUls" target="_blank" rel="noopener">Debug mode apk</a><br><a href="https://drive.google.com/file/d/1SNRg4jmh22L2s5KyHROmaLQ_yjPH1RQI" target="_blank" rel="noopener">arm64-v8 release</a><br><a href="https://drive.google.com/file/d/1eCuFJHGP2AHfUvtxrUgN0ffb1nt76vO7" target="_blank" rel="noopener">armeabi-v7a release</a></p><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/chall_popup.PNG" alt="Challenge"></p><h6 id="Flutter-Dart"><a href="#Flutter-Dart" class="headerlink" title="Flutter / Dart"></a>Flutter / Dart</h6><p>Flutter is Google’s framework for building natively-compiled applications for mobile, web and desktop from a single code base. It follows a “write once, run anywhere” design, so you could basically write the app once in dart, and use flutter to run it anywhere.</p><p>Dart is also created by Google, It is OOP language and has a syntax similar like java. Dart could compile in both Ahead Of Time (AOT) to native code like C/C++ and also to proprietary byte-code, to be later executed by some Just-In-Time(JIT) compiler like Java or JS.</p><h6 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h6><p>We provided a Debug-mode apk, which has a button and a counter which increases it’s value as we tap it.<br><img style="height: 700px; width: 400px;" src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/app.jpeg" alt="App" /></p><p>We can’t get the app source by just extracting like java compiled APKs. Flutter has this cool feature called “hot-reloading” which enables developers to change code in runtime, and only the new code that has been changed will be updated in the app, without the need to compile it again. DartVM takes care of all this work.</p><p>Hence, in debug mode apks, we can find the source code of the app including the comments made. All of the app code is present in the <code>kernel_blob.bin</code> in <code>/assets/flutter_assets/</code> directory of the decompressed APK.</p><p>Use <a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">apktool</a> to extract the components of the apk.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="literal">-jar</span> .\Tools\apktool_2.<span class="number">4.1</span>.jar d .\taptap<span class="literal">-debug</span>.apk</span><br></pre></td></tr></table></figure><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/apktool.PNG" alt="APKTool"> <img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/kernel_blob.PNG" alt="Kernel_blob.bin"></p><p>Using strings you could extract the Dart code, but you’ll need to find the relevant code from the garbage strings.<br>Try to search strings like <code>Sup</code>, <code>NullBreaker CTF</code>, <code>main()</code> and other keywords which we already know from the APK.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings kernel_blob.bin | grep <span class="string">"Sup?"</span> -m1 -B20 -A25</span><br></pre></td></tr></table></figure><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/strings_code.PNG" alt="main dart code from strings"></p><p>Here we could find the main class <code>MyHomePage</code> and the <code>_incrementCounter()</code> function which is called everytime the button is clicked. On looking closer at the <code>setState()</code> of <code>_incrementCounter()</code>, we could find an array named “secret” with some gibberish characters, followed by a little crypto to decode the flag. It’s only executed if the value of <code>_counter</code> goes above 850.</p><p>As we know the count of taps it takes to print the flag, we could possibly sent touch-events using ADB, if we’re too lazy to reverse the crypto. :D</p><p>We could use ADB to map out the counter button coordinate using the <code>getevent</code> command.<br><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/adb-getevent.gif" alt="ADB"><br>And then send touch events using <code>adb input tap</code>, 850 times.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] Sending touch event.."</span>)</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> counter != <span class="number">850</span>:</span><br><span class="line">        os.system(<span class="string">"adb.exe shell input tap 643 1191"</span>)</span><br><span class="line">        counter+=<span class="number">1</span></span><br><span class="line">        print(counter)</span><br></pre></td></tr></table></figure><p>But since this is a very time consuming task, we will reverse the encoding on the flag.</p><p>On looking closely on the decoding function, if the <code>_counter</code> goes above 850, it takes each element from the array and convert it into it’s respective ASCII code, add 1200 to it and performs a bitwise XOR with the whole number. It is then converted back to character and concatenated with the _flag variable.</p><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/decode_function.PNG" alt="decode function"></p><p>Python implementation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">secret = [<span class="string">'\xa7'</span>, <span class="string">'\xab'</span>, <span class="string">'\xca'</span>, <span class="string">'\xbd'</span>, <span class="string">'\xcf'</span>, <span class="string">'\x92'</span>, <span class="string">']'</span>, <span class="string">'\xa7'</span>, <span class="string">'\xcd'</span>, <span class="string">'\x9b'</span>, <span class="string">'Y'</span>, <span class="string">'\xa0'</span>, <span class="string">'\xcd'</span>, <span class="string">'\xb6'</span>, <span class="string">'\xaf'</span>, <span class="string">'X'</span>, <span class="string">'\x9c'</span>, <span class="string">'^'</span>, <span class="string">'^'</span>, <span class="string">'Z'</span>, <span class="string">'\x9b'</span>, <span class="string">'\xb6'</span>, <span class="string">'\x9b'</span>, <span class="string">'Z'</span>, <span class="string">'\x9f'</span>, <span class="string">'Z'</span>, <span class="string">'\x9b'</span>, <span class="string">'\xba'</span>, <span class="string">'X'</span>, <span class="string">'\xa7'</span>, <span class="string">'\xce'</span>, <span class="string">'\x94'</span>]</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> secret:</span><br><span class="line">        flag = flag + chr((ord(secret[count]) + <span class="number">1200</span>) ^ <span class="number">1337</span>)</span><br><span class="line">        count +=<span class="number">1</span></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>And we get the flag.</p><blockquote><p>nbCTF{4nDr0iD_f1u773r_r3v3rS1nG}</p></blockquote><p><strong>App source code:</strong> <a href="https://pastebin.com/V6BuXeWY" target="_blank" rel="noopener">main.dart</a><br><em>will be changed once the challenge repo goes public.</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have a conducted a CTF recently - &lt;a href=&quot;https://ctf.0xdeadbeef.games&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NullBreaker CTF&lt;/a&gt; in associa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Attacking MongoDB&#39;s ObjectID</title>
    <link href="https://odinshell.github.io/2020/05/11/Attacking-MongoDB-s-ObjectID/"/>
    <id>https://odinshell.github.io/2020/05/11/Attacking-MongoDB-s-ObjectID/</id>
    <published>2020-05-11T14:51:15.000Z</published>
    <updated>2020-05-11T19:49:16.696Z</updated>
    
    <content type="html"><![CDATA[<p>Capture the Flag or more commonly known as CTF is a sort of firing range for hackers where they can test their skills and pick up a few new tricks , I personally believe that its a great way to keep you sharp and intrigued to learn new stuff.<br>Recently I attended a CTF conducted by NIT Calicut, It was a fun CTF with almost all Riddle-like challenges. In this post i’ll be describing how i solved a particular challenge from it.</p><h5 id="What-are-these-ID’s"><a href="#What-are-these-ID’s" class="headerlink" title="What are these ID’s?"></a>What are these ID’s?</h5><p><em>Category: Web</em></p><p>The challenge starts off with this <a href="https://frozen-bayou-33918.herokuapp.com/" target="_blank" rel="noopener">link</a>. We’re given a few Valid and Deprecated IDs. On further Googling, I found out that they are MongoDB ObjectIDs used to represent data in MongoDB.</p><p><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-1.PNG" alt="MongoDB ID&#39;s"></p><p>And the page source gave nothing useful other than a comment implying the <code>_id</code> should be used for some-kind of auth.</p><p><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-2.PNG" alt="Page Source"></p><p>First the all, the challenge doesn’t need any sort of authentication, so the comment is a little misleading. There was <code>/log.html</code> with some log data and timestamp, It had the ‘Added flag’ as it’s fourth entry and we had only 3 valid IDs. So it was clear that there was something to do with these timestamps.</p><p><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-3.PNG" alt="log.html"></p><p>On MongoDB’s <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank" rel="noopener">documentation</a>, it was clear that the ObjectID could be reproduced by finding the exact 12-bytes.</p><blockquote><p>The 12-byte ObjectId value consists of:</p><ul><li>a 4-byte timestamp value, representing the ObjectId’s creation, measured in seconds since the Unix epoch</li><li>a 5-byte random value</li><li>a 3-byte incrementing counter, initialized to a random value</li></ul></blockquote><p>In our case, the first 4-byte values could be reproduced since we have the exact timestamp of the Object’s entry. I used <a href="https://steveridout.github.io/mongo-object-time/" target="_blank" rel="noopener">this</a> website to convert the timestamp of ‘Added Flag’ to epoch.<br>First 4-bytes -&gt; <code>5eaaa5ff0000000000000000</code></p><p>On looking closely at the given valid IDs, the second 5 bytes are same on all three entries, i.e <code>0464695443</code><br>Timestamp + 5-byte random value -&gt; <code>5eaaa5ff0464695443000000</code> </p><p>The last 3 bytes are the incrementing counter, on checking the valid ID’s final bytes, we could find a pattern</p><blockquote><p>5ea57c1f04646954437af2be<br>5ea705df04646954437af2bf<br>5ea7f4ef04646954437af2c1</p></blockquote><p><code>be</code>, <code>bf</code> and <code>c1</code>. It follows a pattern from <code>a1</code> to <code>af</code> and change to <code>b1</code>. So i was pretty sure that the next incremented value would be <code>c2</code>.<br>Final ID: <code>5eaaa5ff04646954437af2c2</code></p><p>So on senting a GET requests to <code>/?_id</code> with the ID,<br><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-4.PNG" alt="flag"></p><p>We get a reponse with the flag. </p><blockquote><p>ieee_nitc{53cRet_b3hInd_M0ng0}</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Capture the Flag or more commonly known as CTF is a sort of firing range for hackers where they can test their skills and pick up a few n
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
