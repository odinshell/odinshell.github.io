<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Asjid Kalam</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://odinshell.github.io/"/>
  <updated>2020-05-26T20:43:50.455Z</updated>
  <id>https://odinshell.github.io/</id>
  
  <author>
    <name>Asjid Kalam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reverse Engineering Flutter apps: NullBreaker CTF</title>
    <link href="https://odinshell.github.io/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/"/>
    <id>https://odinshell.github.io/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/</id>
    <published>2020-05-25T10:31:00.000Z</published>
    <updated>2020-05-26T20:43:50.455Z</updated>
    
    <content type="html"><![CDATA[<p>We have a conducted a CTF recently - <a href="https://ctf.0xdeadbeef.games" target="_blank" rel="noopener">NullBreaker CTF</a> in association with <a href="https://ehackify.com/" target="_blank" rel="noopener">eHackify</a> and <a href="https://twitter.com/yetanothersec" target="_blank" rel="noopener">YAS</a>, and in this post, I’ll be discussing about reverse engineering one of the android challenge, <strong>TapTap</strong>. </p><p><em>Files:</em><br><a href="https://drive.google.com/file/d/1AiGME7lV9MCmIzmmOrx2FkO_Kbb8aUls" target="_blank" rel="noopener">Debug mode apk</a><br><a href="https://drive.google.com/file/d/1SNRg4jmh22L2s5KyHROmaLQ_yjPH1RQI" target="_blank" rel="noopener">arm64-v8 release</a><br><a href="https://drive.google.com/file/d/1eCuFJHGP2AHfUvtxrUgN0ffb1nt76vO7" target="_blank" rel="noopener">armeabi-v7a release</a></p><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/chall_popup.PNG" alt="Challenge"></p><h6 id="Flutter-Dart"><a href="#Flutter-Dart" class="headerlink" title="Flutter / Dart"></a>Flutter / Dart</h6><p>Flutter is Google’s framework for building natively-compiled applications for mobile, web and desktop from a single code base. It follows a “write once, run anywhere” design, so you could basically write the app once in dart, and use flutter to run it anywhere.</p><p>Dart is also created by Google, It is OOP language and has a syntax similar like java. Dart could compile in both Ahead Of Time (AOT) to native code like C/C++ and also to proprietary byte-code, to be later executed by some Just-In-Time(JIT) compiler like Java or JS.</p><h6 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h6><p>We provided a Debug-mode apk, which has a button and a counter which increases it’s value as we tap it.<br><img style="height: 700px; width: 400px;" src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/app.jpeg" alt="App" /></p><p>We can’t get the app source by just extracting like java compiled APKs. Flutter has this cool feature called “hot-reloading” which enables developers to change code in runtime, and only the new code that has been changed will be updated in the app, without the need to compile it again. DartVM takes care of all this work.</p><p>Hence, in debug mode apks, we can find the source code of the app including the comments made. All of the app code is present in the <code>kernel_blob.bin</code> in <code>/assets/flutter_assets/</code> directory of the decompressed APK.</p><p>Use <a href="https://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">apktool</a> to extract the components of the apk.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="literal">-jar</span> .\Tools\apktool_2.<span class="number">4.1</span>.jar d .\taptap<span class="literal">-debug</span>.apk</span><br></pre></td></tr></table></figure><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/apktool.PNG" alt="APKTool"> <img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/kernel_blob.PNG" alt="Kernel_blob.bin"></p><p>Using strings you could extract the Dart code, but you’ll need to find the relevant code from the garbage strings.<br>Try to search strings like <code>Sup</code>, <code>NullBreaker CTF</code>, <code>main()</code> and other keywords which we already know from the APK.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings kernel_blob.bin | grep <span class="string">"Sup?"</span> -m1 -B20 -A25</span><br></pre></td></tr></table></figure><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/strings_code.PNG" alt="main dart code from strings"></p><p>Here we could find the main class <code>MyHomePage</code> and the <code>_incrementCounter()</code> function which is called everytime the button is clicked. On looking closer at the <code>setState()</code> of <code>_incrementCounter()</code>, we could find an array named “secret” with some gibberish characters, followed by a little crypto to decode the flag. It’s only executed if the value of <code>_counter</code> goes above 850.</p><p>As we know the count of taps it takes to print the flag, we could possibly sent touch-events using ADB, if we’re too lazy to reverse the crypto. :D</p><p>We could use ADB to map out the counter button coordinate using the <code>getevent</code> command.<br><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/adb-getevent.gif" alt="ADB"><br>And then send touch events using <code>adb input tap</code>, 850 times.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">"[+] Sending touch event.."</span>)</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> counter != <span class="number">850</span>:</span><br><span class="line">        os.system(<span class="string">"adb.exe shell input tap 643 1191"</span>)</span><br><span class="line">        counter+=<span class="number">1</span></span><br><span class="line">        print(counter)</span><br></pre></td></tr></table></figure><p>But since this is a very time consuming task, we will reverse the encoding on the flag.</p><p>On looking closely on the decoding function, if the <code>_counter</code> goes above 850, it takes each element from the array and convert it into it’s respective ASCII code, add 1200 to it and performs a bitwise XOR with the whole number. It is then converted back to character and concatenated with the _flag variable.</p><p><img src="/2020/05/25/Reverse-Engineering-Flutter-apps-NullBreaker-CTF/decode_function.PNG" alt="decode function"></p><p>Python implementation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">secret = [<span class="string">'\xa7'</span>, <span class="string">'\xab'</span>, <span class="string">'\xca'</span>, <span class="string">'\xbd'</span>, <span class="string">'\xcf'</span>, <span class="string">'\x92'</span>, <span class="string">']'</span>, <span class="string">'\xa7'</span>, <span class="string">'\xcd'</span>, <span class="string">'\x9b'</span>, <span class="string">'Y'</span>, <span class="string">'\xa0'</span>, <span class="string">'\xcd'</span>, <span class="string">'\xb6'</span>, <span class="string">'\xaf'</span>, <span class="string">'X'</span>, <span class="string">'\x9c'</span>, <span class="string">'^'</span>, <span class="string">'^'</span>, <span class="string">'Z'</span>, <span class="string">'\x9b'</span>, <span class="string">'\xb6'</span>, <span class="string">'\x9b'</span>, <span class="string">'Z'</span>, <span class="string">'\x9f'</span>, <span class="string">'Z'</span>, <span class="string">'\x9b'</span>, <span class="string">'\xba'</span>, <span class="string">'X'</span>, <span class="string">'\xa7'</span>, <span class="string">'\xce'</span>, <span class="string">'\x94'</span>]</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> secret:</span><br><span class="line">        flag = flag + chr((ord(secret[count]) + <span class="number">1200</span>) ^ <span class="number">1337</span>)</span><br><span class="line">        count +=<span class="number">1</span></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>And we get the flag.</p><blockquote><p>nbCTF{4nDr0iD_f1u773r_r3v3rS1nG}</p></blockquote><p><strong>App source code:</strong> <a href="https://pastebin.com/V6BuXeWY" target="_blank" rel="noopener">main.dart</a><br><em>will be changed once the challenge repo goes public.</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have a conducted a CTF recently - &lt;a href=&quot;https://ctf.0xdeadbeef.games&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NullBreaker CTF&lt;/a&gt; in associa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Attacking MongoDB&#39;s ObjectID</title>
    <link href="https://odinshell.github.io/2020/05/11/Attacking-MongoDB-s-ObjectID/"/>
    <id>https://odinshell.github.io/2020/05/11/Attacking-MongoDB-s-ObjectID/</id>
    <published>2020-05-11T14:51:15.000Z</published>
    <updated>2020-05-11T19:49:16.696Z</updated>
    
    <content type="html"><![CDATA[<p>Capture the Flag or more commonly known as CTF is a sort of firing range for hackers where they can test their skills and pick up a few new tricks , I personally believe that its a great way to keep you sharp and intrigued to learn new stuff.<br>Recently I attended a CTF conducted by NIT Calicut, It was a fun CTF with almost all Riddle-like challenges. In this post i’ll be describing how i solved a particular challenge from it.</p><h5 id="What-are-these-ID’s"><a href="#What-are-these-ID’s" class="headerlink" title="What are these ID’s?"></a>What are these ID’s?</h5><p><em>Category: Web</em></p><p>The challenge starts off with this <a href="https://frozen-bayou-33918.herokuapp.com/" target="_blank" rel="noopener">link</a>. We’re given a few Valid and Deprecated IDs. On further Googling, I found out that they are MongoDB ObjectIDs used to represent data in MongoDB.</p><p><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-1.PNG" alt="MongoDB ID&#39;s"></p><p>And the page source gave nothing useful other than a comment implying the <code>_id</code> should be used for some-kind of auth.</p><p><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-2.PNG" alt="Page Source"></p><p>First the all, the challenge doesn’t need any sort of authentication, so the comment is a little misleading. There was <code>/log.html</code> with some log data and timestamp, It had the ‘Added flag’ as it’s fourth entry and we had only 3 valid IDs. So it was clear that there was something to do with these timestamps.</p><p><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-3.PNG" alt="log.html"></p><p>On MongoDB’s <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank" rel="noopener">documentation</a>, it was clear that the ObjectID could be reproduced by finding the exact 12-bytes.</p><blockquote><p>The 12-byte ObjectId value consists of:</p><ul><li>a 4-byte timestamp value, representing the ObjectId’s creation, measured in seconds since the Unix epoch</li><li>a 5-byte random value</li><li>a 3-byte incrementing counter, initialized to a random value</li></ul></blockquote><p>In our case, the first 4-byte values could be reproduced since we have the exact timestamp of the Object’s entry. I used <a href="https://steveridout.github.io/mongo-object-time/" target="_blank" rel="noopener">this</a> website to convert the timestamp of ‘Added Flag’ to epoch.<br>First 4-bytes -&gt; <code>5eaaa5ff0000000000000000</code></p><p>On looking closely at the given valid IDs, the second 5 bytes are same on all three entries, i.e <code>0464695443</code><br>Timestamp + 5-byte random value -&gt; <code>5eaaa5ff0464695443000000</code> </p><p>The last 3 bytes are the incrementing counter, on checking the valid ID’s final bytes, we could find a pattern</p><blockquote><p>5ea57c1f04646954437af2be<br>5ea705df04646954437af2bf<br>5ea7f4ef04646954437af2c1</p></blockquote><p><code>be</code>, <code>bf</code> and <code>c1</code>. It follows a pattern from <code>a1</code> to <code>af</code> and change to <code>b1</code>. So i was pretty sure that the next incremented value would be <code>c2</code>.<br>Final ID: <code>5eaaa5ff04646954437af2c2</code></p><p>So on senting a GET requests to <code>/?_id</code> with the ID,<br><img src="/2020/05/11/Attacking-MongoDB-s-ObjectID/mongoid-4.PNG" alt="flag"></p><p>We get a reponse with the flag. </p><blockquote><p>ieee_nitc{53cRet_b3hInd_M0ng0}</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Capture the Flag or more commonly known as CTF is a sort of firing range for hackers where they can test their skills and pick up a few n
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
