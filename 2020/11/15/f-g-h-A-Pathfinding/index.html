<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>f=g+h - A* Pathfinding • Asjid Kalam</title><meta name="description" content="f=g+h - A* Pathfinding - Asjid Kalam"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="/css/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Asjid Kalam"><meta name="theme-color" content="#222831"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Asjid Kalam" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Asjid Kalam">Asjid Kalam</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/Asjidkalam" target="_blank">GITHUB</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">f=g+h - A* Pathfinding</h1><div class="post-info"><a></a>Sunday, November 15th 2020</div><div class="post-content"><p><strong>f=g+h</strong> is an medium difficulty programming/misc challenge from <a href="https://yetanothersec.com/yascon2020/" target="_blank" rel="noopener">YASCON 2020</a>, in this blog we’ll be discussing the intended way to solve the challenge.</p>
<h5 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h5><p>We’re given an archive with a word map and a text file with a maze in it. From the text file description and the challenge name, it’s clear that we have to implement A* pathfinding algorithm and find the fastest route to the element <strong>X</strong>.</p>
<p>Pathfinding is basically plotting the shortest route between two points. It is a more practical variant on solving mazes. This field of research is based heavily on Dijkstra’s algorithm for finding the shortest path on a weighted graph. Here we’re going to use an extension of Dijkstra’s algorithm called A* because it achieves better performance by using heuristics to guide its search.</p>
<p><img src="https://miro.medium.com/max/252/1*2jRCHqAbTCY7W7oG5ntMOQ.gif" alt="Dijkstra&#39;s Algorithm" title="Dijkstra&#39;s Algorithm"> </p>
<p style="color:#808080; text-align:center; font-size:small;"><em>Dijkstra's Algorithm</em></p>

<p><img src="https://miro.medium.com/max/252/1*HppvOLfDxXqQRFn0Cv2dHQ.gif" alt="A* Algorithm" title="A* Algorithm"></p>
<p style="color:#808080; text-align:center; font-size:small;"><em>A* Algorithm</em></p>

<h5 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm:"></a>A* Algorithm:</h5><p>A* assigns a weight to each open node equal to the weight of the edge to that node plus the approximate distance between that node and the finish. This approximate distance is found by the heuristic and represents a minimum possible distance between that node and the end. This allows it to eliminate longer paths once an initial path is found.</p>
<p>One important aspect of A* is <em><code>f = g + h</code></em>. The f, g and h variables are in our Node class and get calculated every time we create a new node. Quickly I’ll go over what these variables mean.</p>
<blockquote>
<ul>
<li>F is the total cost of the node.</li>
<li>G is the distance between the current node and the start node.</li>
<li>H is the heuristic — estimated distance from the current node to the end node.</li>
</ul>
</blockquote>
<p>We won’t be implementing A* ourselves, as it’s a waste of time to reinvent the wheel, so instead we’ll be using someone else’s code 😅<br>Here’s a python implementation of A* from scratch: <a href="https://gist.github.com/ryancollingwood/32446307e976a11a1185a5394d6657bc" target="_blank" rel="noopener">gist</a>. All thanks to <a href="https://github.com/ryancollingwood" target="_blank" rel="noopener">ryancollingwood</a> 🙌</p>
<p><img src="/2020/11/15/f-g-h-A-Pathfinding/Pasted%20image%2020201114210854.png" alt="the maze"></p>
<p>Change the maze on <em>line 137</em> with the maze given in the challenge file, Set the destination value to coordinates of the element ‘X’, in our case (7, 8). So the script starts finding the shortest path from (0,0) to (7,8).</p>
<p><img src="/2020/11/15/f-g-h-A-Pathfinding/Pasted%20image%2020201114211632.png" alt="path coordinates"></p>
<p>After getting the coordinates, we need to use them on the image and map out its respective character. All we have to do is just figure out what character stands in the path coordinates to find the flag. You can do that in many ways or even manually. I have created a script to visualize it using Matplotlib and OpenCV, it basically creates a table from the image and plots the points using the coordinates.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> imutils <span class="keyword">import</span> contours</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load image, grayscale, Gaussian blur, Otsu's threshold</span></span><br><span class="line">image = cv2.imread(<span class="string">'map.png'</span>)</span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">blur = cv2.GaussianBlur(gray, (<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">thresh = cv2.threshold(blur, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find contours and remove text inside cells</span></span><br><span class="line">cnts = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cnts = cnts[<span class="number">0</span>] <span class="keyword">if</span> len(cnts) == <span class="number">2</span> <span class="keyword">else</span> cnts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cnts:</span><br><span class="line">    area = cv2.contourArea(c)</span><br><span class="line">    <span class="keyword">if</span> area &lt; <span class="number">4000</span>:</span><br><span class="line">        cv2.drawContours(thresh, [c], <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Invert image</span></span><br><span class="line">invert = <span class="number">255</span> - thresh</span><br><span class="line">offset, old_cY, first = <span class="number">10</span>, <span class="number">0</span>, <span class="literal">True</span></span><br><span class="line">visualize = cv2.cvtColor(invert, cv2.COLOR_GRAY2BGR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find contours, sort from top-to-bottom and then sum up column/rows</span></span><br><span class="line">cnts = cv2.findContours(invert, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cnts = cnts[<span class="number">0</span>] <span class="keyword">if</span> len(cnts) == <span class="number">2</span> <span class="keyword">else</span> cnts[<span class="number">1</span>]</span><br><span class="line">(cnts, _) = contours.sort_contours(cnts, method=<span class="string">"top-to-bottom"</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cnts:</span><br><span class="line">    <span class="comment"># Find centroid</span></span><br><span class="line">    M = cv2.moments(c)</span><br><span class="line"></span><br><span class="line">    cX = int(M[<span class="string">"m10"</span>] / M[<span class="string">"m00"</span>])</span><br><span class="line">    cY = int(M[<span class="string">"m01"</span>] / M[<span class="string">"m00"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># New row</span></span><br><span class="line">    <span class="keyword">if</span> (abs(cY) - abs(old_cY)) &gt; offset:</span><br><span class="line">        <span class="keyword">if</span> first:</span><br><span class="line">            row, table = [], []</span><br><span class="line">            first = <span class="literal">False</span></span><br><span class="line">        old_cY = cY</span><br><span class="line">        table.append(row)</span><br><span class="line">        row = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(tuples)</span>:</span> </span><br><span class="line">    new_tup = () </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> reversed(tuples): </span><br><span class="line">        new_tup = new_tup + (k,) </span><br><span class="line">    <span class="keyword">return</span> new_tup</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment"># coordinates of the flag string</span></span><br><span class="line">flag = [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), </span><br><span class="line">        (<span class="number">0</span>, <span class="number">6</span>), (<span class="number">0</span>, <span class="number">7</span>), (<span class="number">0</span>, <span class="number">8</span>), (<span class="number">0</span>, <span class="number">9</span>), </span><br><span class="line">        (<span class="number">1</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">8</span>), </span><br><span class="line">        (<span class="number">4</span>, <span class="number">8</span>), (<span class="number">5</span>, <span class="number">8</span>), (<span class="number">6</span>, <span class="number">8</span>), (<span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">flag2 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    flag2.append(Reverse(i))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># X(base=19, diff=39) : Y(base=20, diff=42)</span></span><br><span class="line"><span class="keyword">for</span> coordinates <span class="keyword">in</span> flag2:</span><br><span class="line">    <span class="keyword">if</span>(int(coordinates[<span class="number">0</span>]) == <span class="number">0</span>):</span><br><span class="line">        cX = <span class="number">19</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cX = <span class="number">19</span> + (coordinates[<span class="number">0</span>] * <span class="number">39</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(int(coordinates[<span class="number">1</span>]) == <span class="number">0</span>):</span><br><span class="line">        cY = <span class="number">20</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cY = <span class="number">20</span> + (coordinates[<span class="number">1</span>] * <span class="number">41</span>)</span><br><span class="line">    </span><br><span class="line">    print(cX, cY)</span><br><span class="line"></span><br><span class="line">    cv2.circle(visualize, (cX, cY), <span class="number">10</span>, (<span class="number">36</span>, <span class="number">255</span>, <span class="number">12</span>), <span class="number">-1</span>) </span><br><span class="line">    cv2.imshow(<span class="string">"pathfinding"</span>, visualize)</span><br><span class="line">    cv2.waitKey(<span class="number">200</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">print(<span class="string">'Rows: &#123;&#125;'</span>.format(len(table)))</span><br><span class="line">print(<span class="string">'Columns: &#123;&#125;'</span>.format(len(table[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure>

<p><img src="/2020/11/15/f-g-h-A-Pathfinding/pathfinding.gif" alt="visualization"></p>
<p>And we get the string - <strong>AESKDCDOHKKLAOPOLGTMLOME</strong><br>Since the flag is MD5Sum of the path string,</p>
<blockquote>
<p><span style="color:#9e1900;">YASCON{45131ca9f5140debc67047351d21a403}</span></p>
</blockquote>
<hr>
<p>If you wanted to try it for yourself, here’s the challenge files: <a href="http://www.mediafire.com/file/2x0e9xstwyrrjqn/chall.zip/file" target="_blank" rel="noopener">chall.zip</a>  ✌️</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2021/03/13/Prototype-Pollution-to-Command-Injection/">prev</a><a class="next" href="/2020/11/15/crackme-Golang-Reversing/">next</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'odinshell';
var disqus_identifier = '2020/11/15/f-g-h-A-Pathfinding/';
var disqus_title = 'f=g+h - A* Pathfinding';
var disqus_url = 'https://odinshell.github.io/2020/11/15/f-g-h-A-Pathfinding/';
(function () {
    var dsq = document.createElement('script'); dsq.async = true;
    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//odinshell.disqus.com/count.js" async></script><div class="copyright"><br>Made with ❤️ by <a href="https://twitter.com/odinshell" rel="noreferrer" target="_blank">Asjid Kalam</a></div></footer></div></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-42903213-1']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>